
==================== FINAL INTERFACE ====================
2016-09-19 05:17:45.075576 UTC

interface tutor_I0JxLUPgaQCBFIX5GfZik4:Tokens 7103
  interface hash: fc0ee4b116a218048556ba6ba4aac7ec
  ABI hash: b80c1232d47072143c1937ea1b301ca4
  export-list hash: 8dbda48e76e2bb3336585ab991a5abdc
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8dc230b9453f2e206694519f82184084
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tokens.alexGetByte
  Tokens.alexIndexInt16OffAddr
  Tokens.alexIndexInt32OffAddr
  Tokens.alexInputPrevChar
  Tokens.alexScan
  Tokens.alexScanTokens
  Tokens.alexScanUser
  Tokens.alex_accept
  Tokens.alex_action_10
  Tokens.alex_action_11
  Tokens.alex_action_2
  Tokens.alex_action_3
  Tokens.alex_action_4
  Tokens.alex_action_5
  Tokens.alex_action_6
  Tokens.alex_action_7
  Tokens.alex_action_8
  Tokens.alex_action_9
  Tokens.alex_base
  Tokens.alex_check
  Tokens.alex_deflt
  Tokens.alex_scan_tkn
  Tokens.alex_tab_size
  Tokens.alex_table
  Tokens.quickIndex
  Tokens.scanTokens
  Tokens.utf8Encode
  Tokens.AlexAcc{Tokens.AlexAcc Tokens.AlexAccNone Tokens.AlexAccSkip}
  Tokens.AlexAddr{Tokens.AlexA#}
  Tokens.AlexInput
  Tokens.AlexLastAcc{Tokens.AlexLastAcc Tokens.AlexLastSkip Tokens.AlexNone}
  Tokens.AlexReturn{Tokens.AlexEOF Tokens.AlexError Tokens.AlexSkip Tokens.AlexToken}
  Tokens.Byte
  Tokens.Token{Tokens.TokenDiv Tokens.TokenDouble Tokens.TokenLParen Tokens.TokenLog Tokens.TokenMinus Tokens.TokenPlus Tokens.TokenRParen Tokens.TokenSqrt Tokens.TokenSym Tokens.TokenTimes}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array 6e22602c1cc5e362609f0924a7c0a209
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array.Base a0576aaf9a801948417a257cfc0c6084
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Arr 70f35e6bfbc61995e045edb612354887
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exts 7bdf420b67c4b8c9ccc9ea593e90bb92
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
addDependentFile "/home/aman/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/include/ghcversion.h"
addDependentFile "/usr/include/stdc-predef.h"
addDependentFile "src/Tokens.x"
addDependentFile "/usr/lib/ghc/include/ghcconfig.h"
addDependentFile "/usr/lib/ghc/include/ghcplatform.h"
addDependentFile "/usr/lib/ghc/include/ghcautoconf.h"
addDependentFile "/usr/lib/ghc/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/autogen/cabal_macros.h"
555b2f87d58fd01b512692b1f18e7bdc
  $fEqToken :: GHC.Classes.Eq Tokens.Token
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tokens.Token Tokens.$fEqToken_$c== Tokens.$fEqToken_$c/= -}
555b2f87d58fd01b512692b1f18e7bdc
  $fEqToken_$c/= :: Tokens.Token -> Tokens.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Tokens.Token b :: Tokens.Token ->
                 case a of wild {
                   Tokens.TokenDouble a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Tokens.TokenDouble b1
                        -> case a1 of wild2 { GHC.Types.D# x ->
                           case b1 of wild3 { GHC.Types.D# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==## x y) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } } }
                   Tokens.TokenSym a1
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Tokens.TokenSym b1
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } }
                   Tokens.TokenPlus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenPlus -> GHC.Types.False }
                   Tokens.TokenMinus
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenMinus -> GHC.Types.False }
                   Tokens.TokenTimes
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenTimes -> GHC.Types.False }
                   Tokens.TokenDiv
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenDiv -> GHC.Types.False }
                   Tokens.TokenLParen
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenLParen -> GHC.Types.False }
                   Tokens.TokenRParen
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenRParen -> GHC.Types.False }
                   Tokens.TokenLog
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Tokens.TokenLog -> GHC.Types.False }
                   Tokens.TokenSqrt
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Tokens.TokenSqrt -> GHC.Types.False } }) -}
555b2f87d58fd01b512692b1f18e7bdc
  $fEqToken_$c== :: Tokens.Token -> Tokens.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Tokens.Token ds1 :: Tokens.Token ->
                 case ds of wild {
                   Tokens.TokenDouble a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Tokens.TokenDouble b1 -> GHC.Classes.$fEqDouble_$c== a1 b1 }
                   Tokens.TokenSym a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Tokens.TokenSym b1 -> GHC.Base.eqString a1 b1 }
                   Tokens.TokenPlus
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenPlus -> GHC.Types.True }
                   Tokens.TokenMinus
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenMinus -> GHC.Types.True }
                   Tokens.TokenTimes
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenTimes -> GHC.Types.True }
                   Tokens.TokenDiv
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenDiv -> GHC.Types.True }
                   Tokens.TokenLParen
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenLParen -> GHC.Types.True }
                   Tokens.TokenRParen
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenRParen -> GHC.Types.True }
                   Tokens.TokenLog
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Tokens.TokenLog -> GHC.Types.True }
                   Tokens.TokenSqrt
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Tokens.TokenSqrt -> GHC.Types.True } }) -}
29b45b0089e0770d3e37adde4ef1ad34
  $fFunctorAlexLastAcc :: GHC.Base.Functor Tokens.AlexLastAcc
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tokens.AlexLastAcc
                  Tokens.$fFunctorAlexLastAcc_$cfmap
                  Tokens.$fFunctorAlexLastAcc_$c<$ -}
29b45b0089e0770d3e37adde4ef1ad34
  $fFunctorAlexLastAcc_$c<$ ::
    a -> Tokens.AlexLastAcc b -> Tokens.AlexLastAcc a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b eta :: a ds :: Tokens.AlexLastAcc b ->
                 case ds of wild {
                   Tokens.AlexNone -> Tokens.AlexNone @ a
                   Tokens.AlexLastAcc x y dt -> Tokens.AlexLastAcc @ a eta y dt
                   Tokens.AlexLastSkip x dt -> Tokens.AlexLastSkip @ a x dt }) -}
29b45b0089e0770d3e37adde4ef1ad34
  $fFunctorAlexLastAcc_$cfmap ::
    (a -> b) -> Tokens.AlexLastAcc a -> Tokens.AlexLastAcc b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b ds :: a -> b ds1 :: Tokens.AlexLastAcc a ->
                 case ds1 of wild {
                   Tokens.AlexNone -> Tokens.AlexNone @ b
                   Tokens.AlexLastAcc x y dt -> Tokens.AlexLastAcc @ b (ds x) y dt
                   Tokens.AlexLastSkip x dt -> Tokens.AlexLastSkip @ b x dt }) -}
555b2f87d58fd01b512692b1f18e7bdc
  $fShowToken :: GHC.Show.Show Tokens.Token
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tokens.Token
                  Tokens.$fShowToken_$cshowsPrec
                  Tokens.$fShowToken_$cshow
                  Tokens.$fShowToken_$cshowList -}
555b2f87d58fd01b512692b1f18e7bdc
  $fShowToken1 :: Tokens.Token -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Tokens.$fShowToken_$cshowsPrec Tokens.$fShowToken2) -}
50b31433d16341c13b93722b79135d67
  $fShowToken10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenLParen"#) -}
bf199b340cd4b900b37be176ec8dfda3
  $fShowToken11 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken12) -}
8ad24540e3ca2fb686b94853f1765a52
  $fShowToken12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenDiv"#) -}
3bf54bb73a90e1b1fd25c55e52924a99
  $fShowToken13 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken14) -}
abc25540a1ee6d428389f2ac510872a1
  $fShowToken14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenTimes"#) -}
625966f5e6837afbe3d8c0c3dd152168
  $fShowToken15 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken16) -}
c0aaa3968190e7bab9bb6842d5c89c72
  $fShowToken16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenMinus"#) -}
ec746eefc37b5fb93c8cebd10da652b5
  $fShowToken17 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken18) -}
38cde01c536a8aaef57f4ecea85c1734
  $fShowToken18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenPlus"#) -}
35a06bdfc778d7b5c3a11190cf068821
  $fShowToken19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenSym "#) -}
d73a94bb9d8701468ddd0da1cccd7d7a
  $fShowToken2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
bc28c17548d998a29cde3feb2417154e
  $fShowToken20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenDouble "#) -}
6caba704f4b353113dd4c5a22ee5582f
  $fShowToken21 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
f08eb1461a182fa1d195b82f86a06f59
  $fShowToken22 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1289725c4ab2d58cada0e817ad2bc61f
  $fShowToken3 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken4) -}
cffb40ae8fb15adf4b44c8294ee0364f
  $fShowToken4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenSqrt"#) -}
15c7e754b46cd9822811906f9f257398
  $fShowToken5 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken6) -}
7b0ad8f85717fe16c5c651901d64a2d2
  $fShowToken6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenLog"#) -}
8f4e8262c44e0510c7e3807f4afb4949
  $fShowToken7 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken8) -}
de1c51b4e8fcfc19abf05d52b09250e1
  $fShowToken8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TokenRParen"#) -}
39daa7d0270429d25b7089c4191d5706
  $fShowToken9 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken10) -}
555b2f87d58fd01b512692b1f18e7bdc
  $fShowToken_$cshow :: Tokens.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: Tokens.Token ->
                 case x of wild {
                   Tokens.TokenDouble b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Tokens.$fShowToken20
                        (case b1 of ww { GHC.Types.D# ww1 ->
                         GHC.Float.$w$sshowSignedFloat
                           GHC.Float.$fShowDouble_$sshowFloat
                           Tokens.$fShowToken21
                           ww1
                           (GHC.Types.[] @ GHC.Types.Char) })
                   Tokens.TokenSym b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Tokens.$fShowToken19
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Tokens.$fShowToken22))
                   Tokens.TokenPlus -> Tokens.$fShowToken18
                   Tokens.TokenMinus -> Tokens.$fShowToken16
                   Tokens.TokenTimes -> Tokens.$fShowToken14
                   Tokens.TokenDiv -> Tokens.$fShowToken12
                   Tokens.TokenLParen -> Tokens.$fShowToken10
                   Tokens.TokenRParen -> Tokens.$fShowToken8
                   Tokens.TokenLog -> Tokens.$fShowToken6
                   Tokens.TokenSqrt -> Tokens.$fShowToken4 }) -}
555b2f87d58fd01b512692b1f18e7bdc
  $fShowToken_$cshowList :: [Tokens.Token] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Tokens.Token
                   Tokens.$fShowToken1) -}
555b2f87d58fd01b512692b1f18e7bdc
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int -> Tokens.Token -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ a :: GHC.Types.Int ds :: Tokens.Token ->
                 case ds of wild {
                   Tokens.TokenDouble b1
                   -> case a of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww { GHC.Types.D# ww1 ->
                          GHC.Float.$w$sshowSignedFloat
                            GHC.Float.$fShowDouble_$sshowFloat
                            Tokens.$fShowToken21
                            ww1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char Tokens.$fShowToken20 (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Tokens.$fShowToken20
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   Tokens.TokenSym b1
                   -> case a of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Tokens.$fShowToken19
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x1)))
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Tokens.$fShowToken19
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))))) } }
                   Tokens.TokenPlus -> Tokens.$fShowToken17
                   Tokens.TokenMinus -> Tokens.$fShowToken15
                   Tokens.TokenTimes -> Tokens.$fShowToken13
                   Tokens.TokenDiv -> Tokens.$fShowToken11
                   Tokens.TokenLParen -> Tokens.$fShowToken9
                   Tokens.TokenRParen -> Tokens.$fShowToken7
                   Tokens.TokenLog -> Tokens.$fShowToken5
                   Tokens.TokenSqrt -> Tokens.$fShowToken3 }) -}
0376a286e3973146ede1225c79660af1
  $walexGetByte ::
    GHC.Types.Char
    -> [Tokens.Byte]
    -> GHC.Base.String
    -> GHC.Base.Maybe (Tokens.Byte, Tokens.AlexInput)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Types.Char
                   ww1 :: [Tokens.Byte]
                   ww2 :: GHC.Base.String ->
                 case ww1 of wild {
                   []
                   -> case ww2 of wild1 {
                        [] -> GHC.Base.Nothing @ (Tokens.Byte, Tokens.AlexInput)
                        : c s
                        -> case c of wild2 { GHC.Types.C# c# ->
                           let {
                             ww3 :: GHC.Prim.Int# = GHC.Prim.ord# c#
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# ww3 127) of wild3 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<=# ww3 2047) of wild4 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<=# ww3 65535) of wild5 {
                                       GHC.Types.False
                                       -> case GHC.Base.map
                                                 @ GHC.Types.Int
                                                 @ GHC.Word.Word8
                                                 Tokens.alexGetByte1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Int
                                                    (GHC.Types.I#
                                                       (GHC.Prim.+#
                                                          240
                                                          (GHC.Prim.uncheckedIShiftRA# ww3 18)))
                                                    (GHC.Types.:
                                                       @ GHC.Types.Int
                                                       (GHC.Types.I#
                                                          (GHC.Prim.+#
                                                             128
                                                             (GHC.Prim.andI#
                                                                (GHC.Prim.uncheckedIShiftRA# ww3 12)
                                                                63)))
                                                       (GHC.Types.:
                                                          @ GHC.Types.Int
                                                          (GHC.Types.I#
                                                             (GHC.Prim.+#
                                                                128
                                                                (GHC.Prim.andI#
                                                                   (GHC.Prim.uncheckedIShiftRA#
                                                                      ww3
                                                                      6)
                                                                   63)))
                                                          (GHC.Types.:
                                                             @ GHC.Types.Int
                                                             (GHC.Types.I#
                                                                (GHC.Prim.+#
                                                                   128
                                                                   (GHC.Prim.andI# ww3 63)))
                                                             (GHC.Types.[]
                                                                @ GHC.Types.Int))))) of wild6 {
                                            [] -> GHC.Base.Nothing @ (Tokens.Byte, Tokens.AlexInput)
                                            : b bs
                                            -> GHC.Base.Just
                                                 @ (Tokens.Byte, Tokens.AlexInput)
                                                 (b, (wild2, bs, s)) }
                                       GHC.Types.True
                                       -> case GHC.Base.map
                                                 @ GHC.Types.Int
                                                 @ GHC.Word.Word8
                                                 Tokens.alexGetByte1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Int
                                                    (GHC.Types.I#
                                                       (GHC.Prim.+#
                                                          224
                                                          (GHC.Prim.uncheckedIShiftRA# ww3 12)))
                                                    (GHC.Types.:
                                                       @ GHC.Types.Int
                                                       (GHC.Types.I#
                                                          (GHC.Prim.+#
                                                             128
                                                             (GHC.Prim.andI#
                                                                (GHC.Prim.uncheckedIShiftRA# ww3 6)
                                                                63)))
                                                       (GHC.Types.:
                                                          @ GHC.Types.Int
                                                          (GHC.Types.I#
                                                             (GHC.Prim.+#
                                                                128
                                                                (GHC.Prim.andI# ww3 63)))
                                                          (GHC.Types.[]
                                                             @ GHC.Types.Int)))) of wild6 {
                                            [] -> GHC.Base.Nothing @ (Tokens.Byte, Tokens.AlexInput)
                                            : b bs
                                            -> GHC.Base.Just
                                                 @ (Tokens.Byte, Tokens.AlexInput)
                                                 (b, (wild2, bs, s)) } }
                                  GHC.Types.True
                                  -> case GHC.Base.map
                                            @ GHC.Types.Int
                                            @ GHC.Word.Word8
                                            Tokens.alexGetByte1
                                            (GHC.Types.:
                                               @ GHC.Types.Int
                                               (GHC.Types.I#
                                                  (GHC.Prim.+#
                                                     192
                                                     (GHC.Prim.uncheckedIShiftRA# ww3 6)))
                                               (GHC.Types.:
                                                  @ GHC.Types.Int
                                                  (GHC.Types.I#
                                                     (GHC.Prim.+# 128 (GHC.Prim.andI# ww3 63)))
                                                  (GHC.Types.[] @ GHC.Types.Int))) of wild5 {
                                       [] -> GHC.Base.Nothing @ (Tokens.Byte, Tokens.AlexInput)
                                       : b bs
                                       -> GHC.Base.Just
                                            @ (Tokens.Byte, Tokens.AlexInput)
                                            (b, (wild2, bs, s)) } }
                             GHC.Types.True
                             -> case GHC.Base.map
                                       @ GHC.Types.Int
                                       @ GHC.Word.Word8
                                       Tokens.alexGetByte1
                                       (GHC.Types.:
                                          @ GHC.Types.Int
                                          (GHC.Types.I# ww3)
                                          (GHC.Types.[] @ GHC.Types.Int)) of wild4 {
                                  [] -> GHC.Base.Nothing @ (Tokens.Byte, Tokens.AlexInput)
                                  : b bs
                                  -> GHC.Base.Just
                                       @ (Tokens.Byte, Tokens.AlexInput)
                                       (b, (wild2, bs, s)) } } } }
                   : b bs
                   -> GHC.Base.Just
                        @ (Tokens.Byte, Tokens.AlexInput)
                        (b, (ww, bs, ww2)) }) -}
68af41ef2ccd6dc64fd7a1f36d9ccf4e
  $walexScanUser ::
    GHC.Types.Char
    -> [Tokens.Byte]
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Tokens.AlexReturn (GHC.Base.String -> Tokens.Token)
  {- Arity: 4, Strictness: <L,U><S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ @ t
                   ww :: GHC.Types.Char
                   ww1 :: [Tokens.Byte]
                   ww2 :: GHC.Base.String
                   ww3 :: GHC.Prim.Int# ->
                 case Tokens.$walex_scan_tkn
                        @ t
                        @ Tokens.AlexInput
                        0
                        ww
                        ww1
                        ww2
                        ww3
                        (Tokens.AlexNone
                           @ (GHC.Base.String -> Tokens.Token)) of ww4 { (#,#) ww5 ww6 ->
                 case ww5 of wild {
                   Tokens.AlexNone
                   -> case Tokens.$walexGetByte ww ww1 ww2 of wild1 {
                        GHC.Base.Nothing
                        -> Tokens.AlexEOF @ (GHC.Base.String -> Tokens.Token)
                        GHC.Base.Just ds
                        -> Tokens.$WAlexError @ (GHC.Base.String -> Tokens.Token) ww6 }
                   Tokens.AlexLastAcc k input''' dt
                   -> Tokens.AlexToken
                        @ (GHC.Base.String -> Tokens.Token)
                        input'''
                        dt
                        k
                   Tokens.AlexLastSkip input'' dt
                   -> Tokens.AlexSkip
                        @ (GHC.Base.String -> Tokens.Token)
                        input''
                        dt } }) -}
9280df5e640feb7748c81e47de2b00d2
  $walex_scan_tkn ::
    GHC.Prim.Int#
    -> GHC.Types.Char
    -> [Tokens.Byte]
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Tokens.AlexLastAcc (GHC.Base.String -> Tokens.Token)
    -> (# Tokens.AlexLastAcc (GHC.Base.String -> Tokens.Token),
          Tokens.AlexInput #)
  {- Arity: 6, Strictness: <L,U><L,U><S,U><L,U><L,U><L,1*U>,
     Inline: [0] -}
ac2e29ceb756f365a5353562327554dd
  $wgo ::
    GHC.Types.Char
    -> [Tokens.Byte] -> GHC.Base.String -> [Tokens.Token]
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0] -}
6e221dd26de686412a690ff9aacc7914
  type role AlexAcc representational phantom
  data AlexAcc a user = AlexAccNone | AlexAcc a | AlexAccSkip
    Promotable
4e0adc0176f1dcb3ac4c3532511e361e
  data AlexAddr = AlexA# GHC.Prim.Addr#
1415bdd4c5d0f2172fec0d783f7c3ad7
  type AlexInput = (GHC.Types.Char, [Tokens.Byte], GHC.Base.String)
29b45b0089e0770d3e37adde4ef1ad34
  data AlexLastAcc a
    = AlexNone
    | AlexLastAcc a !Tokens.AlexInput {-# UNPACK #-}GHC.Types.Int
    | AlexLastSkip !Tokens.AlexInput {-# UNPACK #-}GHC.Types.Int
2300cf7e64a65719e1e634881622ff0a
  data AlexReturn a
    = AlexEOF
    | AlexError !Tokens.AlexInput
    | AlexSkip !Tokens.AlexInput {-# UNPACK #-}GHC.Types.Int
    | AlexToken !Tokens.AlexInput {-# UNPACK #-}GHC.Types.Int a
2aba589b58a3196209d15ca902ca0135
  type Byte = GHC.Word.Word8
555b2f87d58fd01b512692b1f18e7bdc
  data Token
    = TokenDouble GHC.Types.Double
    | TokenSym GHC.Base.String
    | TokenPlus
    | TokenMinus
    | TokenTimes
    | TokenDiv
    | TokenLParen
    | TokenRParen
    | TokenLog
    | TokenSqrt
e30e19afaecf1bab6670872c04fc1fb2
  alexGetByte ::
    Tokens.AlexInput -> GHC.Base.Maybe (Tokens.Byte, Tokens.AlexInput)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(U,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Tokens.AlexInput ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 Tokens.$walexGetByte ww1 ww2 ww3 }) -}
6e9a7246a8375e1bff945a4ddb4e8fae
  alexGetByte1 :: GHC.Types.Int -> GHC.Word.Word8
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Int ->
                 case x of wild { GHC.Types.I# x# ->
                 GHC.Word.W8# (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# x#)) }) -}
93cf897647ae148daca6fad5d139c7f4
  alexIndexInt16OffAddr ::
    Tokens.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ ds :: Tokens.AlexAddr off :: GHC.Prim.Int# ->
                 case ds of wild { Tokens.AlexA# arr ->
                 GHC.Prim.indexInt16OffAddr# arr off }) -}
c527c1e2190118908914ced48062e5e7
  alexIndexInt32OffAddr ::
    Tokens.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ ds :: Tokens.AlexAddr off :: GHC.Prim.Int# ->
                 case ds of wild { Tokens.AlexA# arr ->
                 GHC.Prim.indexInt32OffAddr# arr off }) -}
b297cb3dc8110706a8ab4111d08da9e5
  alexInputPrevChar :: Tokens.AlexInput -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (GHC.Types.Char, [Tokens.Byte], GHC.Base.String) ->
                 case ds of wild { (,,) c ds1 ds2 -> c }) -}
5cce3c0b4c1d97e5c85aedc24fc62406
  alexScan ::
    Tokens.AlexInput
    -> GHC.Types.Int
    -> Tokens.AlexReturn (GHC.Base.String -> Tokens.Token)
  {- Arity: 2, Strictness: <S(LSL),U(U,U,U)><S,1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ input :: Tokens.AlexInput ds :: GHC.Types.Int ->
                 case ds of wild { GHC.Types.I# sc ->
                 Tokens.alexScanUser
                   @ GHC.Prim.Any
                   (GHC.Err.undefined @ GHC.Prim.Any)
                   input
                   (GHC.Types.I# sc) }) -}
66053cbf298f321e8a3a5de11c985ab2
  alexScanTokens :: GHC.Base.String -> [Tokens.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ str :: GHC.Base.String ->
                 Tokens.alexScanTokens_go
                   (Tokens.alexScanTokens1, GHC.Types.[] @ Tokens.Byte, str)) -}
25949e12458b1110bc27f1833b5d0a34
  alexScanTokens1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '\n') -}
3a32953c32047a09186497d79c24ae13
  alexScanTokens_go ::
    (GHC.Types.Char, [Tokens.Byte], GHC.Base.String) -> [Tokens.Token]
  {- Arity: 1, Strictness: <S(LSL),1*U(U,U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Types.Char, [Tokens.Byte], GHC.Base.String) ->
                 case w of ww { (,,) ww1 ww2 ww3 -> Tokens.$wgo ww1 ww2 ww3 }) -}
5411a7ad5e66062326c63abba2522b7d
  alexScanUser ::
    t
    -> Tokens.AlexInput
    -> GHC.Types.Int
    -> Tokens.AlexReturn (GHC.Base.String -> Tokens.Token)
  {- Arity: 3, Strictness: <L,A><S(LSL),U(U,U,U)><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t w :: t w1 :: Tokens.AlexInput w2 :: GHC.Types.Int ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case w2 of ww4 { GHC.Types.I# ww5 ->
                 Tokens.$walexScanUser @ t ww1 ww2 ww3 ww5 } }) -}
4040e5f540d029dd4497f36baf027ae3
  alex_accept ::
    GHC.Arr.Array
      GHC.Types.Int
      (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
  {- Unfolding: (\ @ user ->
                 GHC.ST.runSTRep
                   @ (GHC.Arr.Array
                        GHC.Types.Int
                        (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user))
                   (Tokens.alex_accept1 @ user)) -}
3a619dc9568483a7262f825a03cc7e47
  alex_accept1 ::
    GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          GHC.Arr.Array
            GHC.Types.Int
            (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user) #)
  {- Arity: 1,
     Unfolding: (\ @ user @ s s1# :: GHC.Prim.State# s[OneShot] ->
                 case GHC.Prim.newArray#
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        @ s
                        28
                        (GHC.Arr.arrEleBottom
                           @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user))
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        0
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        ipv of s4# { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        1
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4# of s4#1 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        2
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#1 of s4#2 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        3
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#2 of s4#3 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        4
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#3 of s4#4 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        5
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#4 of s4#5 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        6
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#5 of s4#6 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        7
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#6 of s4#7 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        8
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#7 of s4#8 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        9
                        (Tokens.AlexAccNone @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#8 of s4#9 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        10
                        (Tokens.AlexAccSkip @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#9 of s4#10 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        11
                        (Tokens.AlexAccSkip @ (GHC.Base.String -> Tokens.Token) @ user)
                        s4#10 of s4#11 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        12
                        (Tokens.alex_accept12 @ user)
                        s4#11 of s4#12 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        13
                        (Tokens.alex_accept12 @ user)
                        s4#12 of s4#13 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        14
                        (Tokens.alex_accept11 @ user)
                        s4#13 of s4#14 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        15
                        (Tokens.alex_accept10 @ user)
                        s4#14 of s4#15 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        16
                        (Tokens.alex_accept9 @ user)
                        s4#15 of s4#16 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        17
                        (Tokens.alex_accept8 @ user)
                        s4#16 of s4#17 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        18
                        (Tokens.alex_accept7 @ user)
                        s4#17 of s4#18 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        19
                        (Tokens.alex_accept6 @ user)
                        s4#18 of s4#19 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        20
                        (Tokens.alex_accept5 @ user)
                        s4#19 of s4#20 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        21
                        (Tokens.alex_accept4 @ user)
                        s4#20 of s4#21 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        22
                        (Tokens.alex_accept3 @ user)
                        s4#21 of s4#22 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        23
                        (Tokens.alex_accept3 @ user)
                        s4#22 of s4#23 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        24
                        (Tokens.alex_accept3 @ user)
                        s4#23 of s4#24 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        25
                        (Tokens.alex_accept3 @ user)
                        s4#24 of s4#25 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        26
                        (Tokens.alex_accept3 @ user)
                        s4#25 of s4#26 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        27
                        (Tokens.alex_accept3 @ user)
                        s4#26 of s4#27 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ s
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                        ipv1
                        s4#27 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user)
                      Tokens.$fShowToken2
                      Tokens.alex_accept2
                      28
                      ipv3 #) } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
14de0987ea256b9fe441e827e74a55d4
  alex_accept10 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_4 @ GHC.Base.String)) -}
120515b51e278ae3b207448bbaf5bbf0
  alex_accept11 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_3 @ GHC.Base.String)) -}
f8eb467b792bc4b68fd1857bfc6c0e48
  alex_accept12 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   Tokens.alex_action_2) -}
5c44775d81263823cf5e77bcccd06fa4
  alex_accept2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 27) -}
954e72cc4df5de87beb76a4b5b7c56f0
  alex_accept3 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   Tokens.TokenSym) -}
a00b2be18cb985ee413496d2ff1b6136
  alex_accept4 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_10 @ GHC.Base.String)) -}
679f21064c5c4efc4453006248b39ffa
  alex_accept5 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_9 @ GHC.Base.String)) -}
7f3a2c1a65b192c8deecd90f89f5be1a
  alex_accept6 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_8 @ GHC.Base.String)) -}
da8a5467ff3fd78682ac6026766a5163
  alex_accept7 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_7 @ GHC.Base.String)) -}
9ea7b2d9df8baf004a6c2f1a6733dafb
  alex_accept8 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_6 @ GHC.Base.String)) -}
178b060cb49e5f686d3a5d9424dc0d17
  alex_accept9 ::
    Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Tokens.AlexAcc
                   @ (GHC.Base.String -> Tokens.Token)
                   @ user
                   (Tokens.alex_action_5 @ GHC.Base.String)) -}
7e72e529fdf1a142cc486d8e84a8ce5b
  alex_action_1 :: GHC.Types.Double
  {- Strictness: b -}
0d2075e0b789e705230fd455defee229
  alex_action_10 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenLog) -}
176af7c1b4a7c7675d87220791186d75
  alex_action_11 :: GHC.Base.String -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (0, True, True) Tokens.TokenSym -}
09c305fc4b3d65721ed0694b52c463cf
  alex_action_12 :: GHC.Types.Double
  {- Strictness: b -}
ab1d56a7c199c9e74c27fd8c4a46b6e0
  alex_action_13 :: Text.ParserCombinators.ReadP.P GHC.Types.Double
  {- Unfolding: ((GHC.Read.$fReadDouble9
                    GHC.Read.$fReadDouble_$sconvertFrac
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <GHC.Types.Double>_R)
                   @ GHC.Types.Double
                   (Text.Read.readEither5 @ GHC.Types.Double)) -}
192d851cc457a9a1e413fa226de74837
  alex_action_2 :: GHC.Base.String -> Tokens.Token
  {- Arity: 1, Strictness: <L,U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 Tokens.TokenDouble
                   (case Text.Read.readEither6
                           @ GHC.Types.Double
                           (Text.ParserCombinators.ReadP.run
                              @ GHC.Types.Double
                              Tokens.alex_action_13
                              w) of wild {
                      [] -> Tokens.alex_action_12
                      : x ds
                      -> case ds of wild1 {
                           [] -> x : ipv ipv1 -> Tokens.alex_action_1 } })) -}
2853e7a611f8de81cacd9ca61ad01ec7
  alex_action_3 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenPlus) -}
bd51c957ac899ea10608d748d5873d3b
  alex_action_4 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenMinus) -}
9af9ab9f1d4d67365124c052de33897a
  alex_action_5 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenTimes) -}
147e5bb48c227903c5d3a2ae137f9778
  alex_action_6 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenDiv) -}
f900970dfc26921855919d9588b8cdf0
  alex_action_7 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenLParen) -}
b115c2abbea02f772a76c725301c5b86
  alex_action_8 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenRParen) -}
ea06965094a4c4cc819eb21c6784f009
  alex_action_9 :: t -> Tokens.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t s :: t -> Tokens.TokenSqrt) -}
4f8d5fad5d0bf5dc8009c9cbad41476b
  alex_base :: Tokens.AlexAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Tokens.AlexA#
                   "\\248\\255\\255\\255\\180\\255\\255\\255\NUL\NUL\NUL\NUL%\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\165\NUL\NUL\NUL%\SOH\NUL\NUL%\STX\NUL\NUL\\229\SOH\NUL\NUL\NUL\NUL\NUL\NUL\\253\\255\\255\\255\\219\STX\NUL\NUL\\219\\255\\255\\255\\184\STX\NUL\NUL\NUL\NUL\NUL\NUL\\232\\255\\255\\255\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\203\STX\NUL\NUL\\180\ETX\NUL\NUL\b\EOT\NUL\NUL\\\EOT\NUL\NUL\\176\EOT\NUL\NUL\EOT\ENQ\NUL\NULX\ENQ\NUL\NUL\\172\ENQ\NUL\NUL"#) -}
dfcb9c96799473fe03c750addeacb368
  alex_check :: Tokens.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
a5bc06c0c8bc6d10ebdeb5808d604f12
  alex_deflt :: Tokens.AlexAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Tokens.AlexA#
                   "\\255\\255\t\NUL\t\NUL\STX\NUL\STX\NUL\\255\\255\\255\\255\v\NUL\v\NUL\v\NUL\\255\\255\v\NUL\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255"#) -}
536cfae74fce3da1595190a7c7bd1100
  alex_scan_tkn ::
    t
    -> t1
    -> GHC.Prim.Int#
    -> Tokens.AlexInput
    -> GHC.Prim.Int#
    -> Tokens.AlexLastAcc (GHC.Base.String -> Tokens.Token)
    -> (Tokens.AlexLastAcc (GHC.Base.String -> Tokens.Token),
        Tokens.AlexInput)
  {- Arity: 6,
     Strictness: <L,A><L,A><L,U><S(LSL),1*U(U,U,U)><L,U><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   @ t1
                   w :: t
                   w1 :: t1
                   w2 :: GHC.Prim.Int#
                   w3 :: Tokens.AlexInput
                   w4 :: GHC.Prim.Int#
                   w5 :: Tokens.AlexLastAcc (GHC.Base.String -> Tokens.Token) ->
                 case w3 of ww { (,,) ww1 ww2 ww3 ->
                 case Tokens.$walex_scan_tkn
                        @ t
                        @ t1
                        w2
                        ww1
                        ww2
                        ww3
                        w4
                        w5 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } }) -}
a7dac3b44440a47f2d289991447ae0fc
  alex_tab_size :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8) -}
d6ef145138615959b89b32e934a4e561
  alex_table :: Tokens.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
0fd745e96d0fd2d69c4b16b23444bff1
  quickIndex ::
    GHC.Arr.Array
      GHC.Types.Int
      (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) GHC.Prim.Any)
    -> GHC.Types.Int
    -> Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) GHC.Prim.Any
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SSLL),1*U(1*H,1*H,A,U)><S,1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: GHC.Arr.Array
                            GHC.Types.Int
                            (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) GHC.Prim.Any)
                   eta1 :: GHC.Types.Int ->
                 case eta of wild { GHC.Arr.Array ds2 ds3 dt arr# ->
                 case eta1 of wild1 { GHC.Types.I# i# ->
                 case GHC.Prim.indexArray#
                        @ (Tokens.AlexAcc (GHC.Base.String -> Tokens.Token) GHC.Prim.Any)
                        arr#
                        i# of ds4 { (##) ipv ->
                 ipv } } }) -}
1bcd5fcc997053bd4844aaa405849e21
  scanTokens :: GHC.Base.String -> [Tokens.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True) Tokens.alexScanTokens -}
59d0f1c1683778a97b6842bc5aadb97b
  utf8Encode :: GHC.Types.Char -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Char ->
                 case x of wild { GHC.Types.C# c# ->
                 GHC.Base.build
                   @ GHC.Word.Word8
                   (\ @ b1
                      c :: GHC.Word.Word8 -> b1 -> b1[OneShot]
                      n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Int
                      @ b1
                      (GHC.Base.mapFB
                         @ GHC.Word.Word8
                         @ b1
                         @ GHC.Types.Int
                         c
                         Tokens.alexGetByte1)
                      n
                      (Tokens.utf8Encode1 (GHC.Types.I# (GHC.Prim.ord# c#)))) }) -}
a83491a28a44856a2f3943bfbf55a5fd
  utf8Encode1 :: GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww1 127) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww1 2047) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# ww1 65535) of wild2 {
                             GHC.Types.False
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I#
                                     (GHC.Prim.+# 240 (GHC.Prim.uncheckedIShiftRA# ww1 18)))
                                  (GHC.Types.:
                                     @ GHC.Types.Int
                                     (GHC.Types.I#
                                        (GHC.Prim.+#
                                           128
                                           (GHC.Prim.andI#
                                              (GHC.Prim.uncheckedIShiftRA# ww1 12)
                                              63)))
                                     (GHC.Types.:
                                        @ GHC.Types.Int
                                        (GHC.Types.I#
                                           (GHC.Prim.+#
                                              128
                                              (GHC.Prim.andI#
                                                 (GHC.Prim.uncheckedIShiftRA# ww1 6)
                                                 63)))
                                        (GHC.Types.:
                                           @ GHC.Types.Int
                                           (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                           (GHC.Types.[] @ GHC.Types.Int))))
                             GHC.Types.True
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I#
                                     (GHC.Prim.+# 224 (GHC.Prim.uncheckedIShiftRA# ww1 12)))
                                  (GHC.Types.:
                                     @ GHC.Types.Int
                                     (GHC.Types.I#
                                        (GHC.Prim.+#
                                           128
                                           (GHC.Prim.andI# (GHC.Prim.uncheckedIShiftRA# ww1 6) 63)))
                                     (GHC.Types.:
                                        @ GHC.Types.Int
                                        (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                        (GHC.Types.[] @ GHC.Types.Int))) }
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Int
                             (GHC.Types.I#
                                (GHC.Prim.+# 192 (GHC.Prim.uncheckedIShiftRA# ww1 6)))
                             (GHC.Types.:
                                @ GHC.Types.Int
                                (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                (GHC.Types.[] @ GHC.Types.Int)) }
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Int
                        (GHC.Types.I# ww1)
                        (GHC.Types.[] @ GHC.Types.Int) } }) -}
instance GHC.Classes.Eq [Tokens.Token] = Tokens.$fEqToken
instance GHC.Base.Functor [Tokens.AlexLastAcc]
  = Tokens.$fFunctorAlexLastAcc
instance GHC.Show.Show [Tokens.Token] = Tokens.$fShowToken
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

