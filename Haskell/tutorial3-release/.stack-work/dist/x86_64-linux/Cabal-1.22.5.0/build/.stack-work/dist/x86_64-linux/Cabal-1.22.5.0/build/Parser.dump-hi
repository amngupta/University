
==================== FINAL INTERFACE ====================
2016-09-29 04:57:38.124922 UTC

interface tutor_GLltxzxYifw5EdUanoMNpW:Parser 7103
  interface hash: c46d057f959d4e14900d1fd63ba88768
  ABI hash: 4f95eb1f18eb52f067d6816b48c3f54d
  export-list hash: 9be9e836ee0b676018f59ad731cd00a0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 43309756800e558b71094415e5201f2b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Parser.parseExpr
module dependencies: Declare Tokens
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array 6e22602c1cc5e362609f0924a7c0a209
import  -/  base-4.8.2.0:Control.Applicative a8ebf5ad4932b411ad7725da68be9801
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:GHC.Arr 70f35e6bfbc61995e045edb612354887
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exts 7bdf420b67c4b8c9ccc9ea593e90bb92
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  Declare 9a58678d97fbc4b12602f590ffa3cf3a
  exports: 582075eb9e752d9bf992b69884b4667e
  Add d84278e89fd7b62ebe27af50807c7bd4
  Decl ff269f68838415830016c238633a3f76
  Div 5696fc9368e107c3ea9ca8e0c793fe6d
  Mult 85e19df3b0e365bc81050e85d9b0c17e
  Num 95886d135c9c2be819f7acded04a9385
  Sub 616f095aa49f54a8000a41d2348d0462
  Var de999b52bdc289f2d3c62768c981ff51
import  -/  Tokens eab5325c9b8513cef925b659bc6593d4
  exports: c5ae66807c05952fe335bfecc40f9400
  Token 68b948bc53d126e7ec51d4754d7ab3d2
  TokenDiv 3279715c97241bf1a64accb87309405d
  TokenEq f5ca87caef644e61d416ab9d6d021b1e
  TokenInt 53898cdd0b475101ff5d4dacf56ebf26
  TokenLParen 40fc7f8c1aa6d83fe87aa741a0cbce50
  TokenMinus e471f04c5e63fff75db9acf9f16aa4a0
  TokenPlus 03a76babc7adf520d16a698ff7bf9ebc
  TokenRParen 6c869d8189678a278978b08910539c9f
  TokenSemiColon e8e5ff1c2e91bc9d6bd1f49bc28168a5
  TokenSym 666b7c41f0899b5175f607dfbe013491
  TokenTimes 5373fb521c6c120bce3ebb7a5babef7b
  TokenVar d750b4cfb975d131e2f1884d64fc1547
  scanTokens 8bd52c08582f95f18284f270a06a4eaf
addDependentFile "/home/aman/.stack/programs/x86_64-linux/ghc-7.10.3/lib/ghc-7.10.3/include/ghcversion.h"
addDependentFile "/usr/include/stdc-predef.h"
addDependentFile "/usr/lib/ghc/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/autogen/cabal_macros.h"
fixities infixr 9 HappyStk, infixr 9 HappyStk
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity ∷
    GHC.Base.Applicative Parser.HappyIdentity
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fFunctorHappyIdentity
                  Parser.$fApplicativeHappyIdentity_$cpure
                  Parser.$fApplicativeHappyIdentity_$sap
                  Parser.$fApplicativeHappyIdentity_$c*>
                  Parser.$fApplicativeHappyIdentity_$c<* -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity1 ∷
    forall a b.
    Parser.HappyIdentity a
    → Parser.HappyIdentity b → Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1
                   @ b
                   eta ∷ Parser.HappyIdentity a1
                   eta1 ∷ Parser.HappyIdentity b →
                 eta) -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity2 ∷
    forall a b.
    Parser.HappyIdentity (a → b) → Parser.HappyIdentity a → b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1
                   @ b
                   m1 ∷ Parser.HappyIdentity (a1 → b)
                   m2 ∷ Parser.HappyIdentity a1 →
                 m1 `cast` (Parser.NTCo:HappyIdentity[0] <a1 → b>_R)
                   m2 `cast` (Parser.NTCo:HappyIdentity[0] <a1>_R)) -}
7c51c1935569e9c1b242a500daec56f7
  $fApplicativeHappyIdentity3 ∷ forall a. a → a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a1 tpl ∷ a1 → tpl) -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity_$c*> ∷
    forall a b.
    Parser.HappyIdentity a
    → Parser.HappyIdentity b → Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1
                   @ b
                   eta ∷ Parser.HappyIdentity a1
                   eta1 ∷ Parser.HappyIdentity b →
                 eta1) -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity_$c<* ∷
    forall a b.
    Parser.HappyIdentity a
    → Parser.HappyIdentity b → Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity1 -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity_$cpure ∷
    forall a. a → Parser.HappyIdentity a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity3
                  `cast`
                (forall a1.
                 <a1>_R →_R Sym (Parser.NTCo:HappyIdentity[0] <a1>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fApplicativeHappyIdentity_$sap ∷
    forall a b.
    Parser.HappyIdentity (a → b)
    → Parser.HappyIdentity a → Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeHappyIdentity2
                  `cast`
                (forall a1 b.
                 <Parser.HappyIdentity (a1 → b)>_R
                 →_R <Parser.HappyIdentity a1>_R
                 →_R Sym (Parser.NTCo:HappyIdentity[0] <b>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fFunctorHappyIdentity ∷ GHC.Base.Functor Parser.HappyIdentity
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fFunctorHappyIdentity_$cfmap
                  Parser.$fFunctorHappyIdentity_$c<$ -}
3523075384fee6967979a7922bb34ba2
  $fFunctorHappyIdentity1 ∷
    forall a b. a → Parser.HappyIdentity b → a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1 @ b eta ∷ a1 eta1 ∷ Parser.HappyIdentity b → eta) -}
3523075384fee6967979a7922bb34ba2
  $fFunctorHappyIdentity2 ∷
    forall a b. (a → b) → Parser.HappyIdentity a → b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1 @ b f ∷ a1 → b ds ∷ Parser.HappyIdentity a1 →
                 f ds `cast` (Parser.NTCo:HappyIdentity[0] <a1>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fFunctorHappyIdentity_$c<$ ∷
    forall a b. a → Parser.HappyIdentity b → Parser.HappyIdentity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fFunctorHappyIdentity1
                  `cast`
                (forall a1 b.
                 <a1>_R
                 →_R <Parser.HappyIdentity b>_R
                 →_R Sym (Parser.NTCo:HappyIdentity[0] <a1>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fFunctorHappyIdentity_$cfmap ∷
    forall a b.
    (a → b) → Parser.HappyIdentity a → Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fFunctorHappyIdentity2
                  `cast`
                (forall a1 b.
                 <a1 → b>_R
                 →_R <Parser.HappyIdentity a1>_R
                 →_R Sym (Parser.NTCo:HappyIdentity[0] <b>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fMonadHappyIdentity ∷ GHC.Base.Monad Parser.HappyIdentity
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.HappyIdentity
                  Parser.$fApplicativeHappyIdentity
                  Parser.$fMonadHappyIdentity_$c>>=
                  Parser.$fMonadHappyIdentity_$c>>
                  Parser.$fApplicativeHappyIdentity_$cpure
                  Parser.$fMonadHappyIdentity_$s$dmfail -}
3523075384fee6967979a7922bb34ba2
  $fMonadHappyIdentity_$c>> ∷
    forall a b.
    Parser.HappyIdentity a
    → Parser.HappyIdentity b → Parser.HappyIdentity b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a1
                   @ b
                   m1 ∷ Parser.HappyIdentity a1
                   k ∷ Parser.HappyIdentity b →
                 Parser.$fMonadHappyIdentity_$c>>=
                   @ a1
                   @ b
                   m1
                   (\ ds ∷ a1[OneShot] → k)) -}
3523075384fee6967979a7922bb34ba2
  $fMonadHappyIdentity_$c>>= ∷
    forall a b.
    Parser.HappyIdentity a
    → (a → Parser.HappyIdentity b) → Parser.HappyIdentity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a1
                   @ b
                   ds ∷ Parser.HappyIdentity a1
                   q ∷ a1 → Parser.HappyIdentity b →
                 q ds `cast` (Parser.NTCo:HappyIdentity[0] <a1>_R)) -}
3523075384fee6967979a7922bb34ba2
  $fMonadHappyIdentity_$s$dmfail ∷
    forall a. GHC.Base.String → Parser.HappyIdentity a
  {- Arity: 1, Strictness: <B,U>b,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a1 eta ∷ [GHC.Types.Char] →
                 GHC.Err.error @ (Parser.HappyIdentity a1) eta) -}
50179be6c0451cee0e1e7e639d379821
  type role HappyAbsSyn phantom
  newtype HappyAbsSyn t4 = HappyAbsSyn Parser.HappyAny
466c762cad3ec2ea3d14ee108023b7fc
  data HappyAddr = HappyA# GHC.Prim.Addr#
b8d5da1a34ee5c1325303cf18e1dba5c
  type HappyAny = GHC.Prim.Any
3523075384fee6967979a7922bb34ba2
  newtype HappyIdentity a = HappyIdentity a
    Promotable
b6d0e64c2bc86184fa5beb1340c3d5e2
  data HappyStk a = HappyStk a (Parser.HappyStk a)
    RecFlag: Recursive
    Promotable
12ae57a3ad2dfcda9c56cf23e29db715
  data Happy_IntList = HappyCons GHC.Prim.Int# Parser.Happy_IntList
    RecFlag: Recursive
514a9eb92646ea752b3b8f930d87644e
  notHappyAtAll ∷ forall a. a
  {- Strictness: b -}
f1eb06fc532798f20699763f35e09840
  parseExpr ∷ GHC.Base.String → Declare.Exp
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.parseExpr1
                  `cast`
                (<GHC.Base.String>_R
                 →_R Parser.NTCo:HappyIdentity[0]
                         (UnivCo mkUnsafeCo representational (Parser.HappyAbsSyn
                                                                Declare.Exp) Declare.Exp)) -}
989580574f3b9945e027e218ab5c748f
  parseExpr1 ∷
    GHC.Base.String
    → Parser.HappyIdentity (Parser.HappyAbsSyn Declare.Exp)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ x ∷ GHC.Base.String →
                 Parser.parseExpr_happyNewToken
                   0
                   (Parser.notHappyAtAll @ Parser.Happy_IntList)
                   (Parser.notHappyAtAll
                      @ (Parser.HappyStk (Parser.HappyAbsSyn Declare.Exp)))
                   (Tokens.alexScanTokens x)) -}
a303d5059a32915250d3514034674aff
  parseExpr_happyNewToken ∷
    GHC.Prim.Int#
    → Parser.Happy_IntList
    → Parser.HappyStk (Parser.HappyAbsSyn Declare.Exp)
    → [Tokens.Token]
    → Parser.HappyIdentity (Parser.HappyAbsSyn Declare.Exp)
  {- Arity: 4, Strictness: <L,U><L,U><L,U(U,U)><S,1*U> -}
instance GHC.Base.Applicative [Parser.HappyIdentity]
  = Parser.$fApplicativeHappyIdentity
instance GHC.Base.Functor [Parser.HappyIdentity]
  = Parser.$fFunctorHappyIdentity
instance GHC.Base.Monad [Parser.HappyIdentity]
  = Parser.$fMonadHappyIdentity
"SPEC/Parser $dmfail @ HappyIdentity" [ALWAYS] forall $dMonad ∷ GHC.Base.Monad
                                                                  Parser.HappyIdentity
  GHC.Base.$dmfail @ Parser.HappyIdentity $dMonad
  = Parser.$fMonadHappyIdentity_$s$dmfail
"SPEC/Parser ap @ HappyIdentity _ _" [ALWAYS] forall @ a1
                                                     @ b
                                                     $dMonad ∷ GHC.Base.Monad Parser.HappyIdentity
  GHC.Base.ap @ Parser.HappyIdentity @ a1 @ b $dMonad
  = Parser.$fApplicativeHappyIdentity_$sap @ a1 @ b
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

